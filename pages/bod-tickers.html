<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-468B94S87K"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-468B94S87K');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buy on Dip - All Tickers</title>
    <style>
        /* Color Palette */
        :root {
            --blue: #003764;
            --light-blue: #5EB3E4;
            --golden-yellow: #FFC600;
            --black: #000000;
            --gray: #969595;
            --light-gray: #E0E1E1;
            --bright-green: #92D050;
            --orange: #F25C05;
            --purple: #AA2E9C;
            --red: #C00000;
            --dark-gray: #595959;
        }

        /* Base Styles */
        body, html {
            font-family: Arial, Helvetica, sans-serif;
            background-color: #fff;
            color: #000;
            margin: 0;
            padding: 0;
        }

        /* Navigation Bar Styles */
        nav {
            background: var(--light-gray);
            padding: 1rem 0;
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            border-bottom: 2px solid var(--blue);
        }

        nav a {
            color: var(--blue);
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1rem;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            transition: background 0.2s, color 0.2s;
        }

        nav a:hover,
        nav a:focus {
            background: var(--blue);
            color: #fff;
            text-decoration: none;
        }

        /* Chart Styles */
        .chart-container {
            margin-bottom: 2em;
            border: 1px solid #eee;
            padding: 1em;
            border-radius: 8px;
            background: #fafafa;
        }
        .chart-title {
            font-size: 1.2em;
            margin-bottom: 0.5em;
        }

    /* Shared metric styles moved to css/ticker-metrics.css */

        /* Heading Styles */
        h1 {
            font-family: Arial, Helvetica, sans-serif;
            font-size: 2.1rem;
            font-weight: bold;
            color: var(--blue);
            margin: 1rem 0;
            text-align: center;
        }

        h2 {
            font-family: Arial, Helvetica, sans-serif;
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--light-blue);
            margin: 0.5rem 0;
            text-align: center;
        }

        /* Responsive Design for Navigation */
        @media (max-width: 700px) {
            nav {
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
                padding: 0.5rem 0;
            }
            nav a {
                font-size: 1rem;
                padding: 0.5rem 1rem;
                width: 100%;
                text-align: center;
                border-radius: 0;
            }
        }

        @media (max-width: 400px) {
            nav a {
                font-size: 0.95rem;
                padding: 0.5rem 0.5rem;
            }
        }
        /* Period button styles (match DCA page) */
        #download-analysis-btn, #calculate-btn, .period-btn {
            transition: all 0.3s ease;
        }

        .period-btn {
            padding: 10px 20px;
            margin: 0 5px;
            background-color: var(--bright-green);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.95em;
        }

        .period-btn:hover:not(:disabled) {
            background-color: #7dd35e !important;
            transform: translateY(-1px);
        }

        .period-btn:disabled {
            cursor: not-allowed;
            opacity: 0.5;
            background-color: var(--gray) !important;
        }

        .period-btn.active {
            background-color: var(--orange) !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .period-btn.active:hover {
            background-color: var(--orange) !important;
            transform: none !important;
        }
    </style>
    <link rel="stylesheet" href="../css/ticker-metrics.css">
</head>
<body>
    <nav>
        <a href="../index.html">Home</a>
        <a href="dca.html">Dollar Cost Averaging Analysis</a>
        <a href="bod.html">Buy-on-Dip Analysis</a>
        <a href="dca-tickers.html">Dollar Cost Averaging (All Tickers)</a>
        <a href="bod-tickers.html">Buy-on-Dip (All Tickers)</a>
        <a href="dca-strat.html">Advanced Dollar Cost Averaging</a>
        <a href="bod-strat.html">Advanced Buy-on-Dip</a>
        <a href="about.html">About</a>
    </nav>
    <h1>Buy-on-Dip Strategy - Per Ticker</h1>
    <h2>Buying 1 share for each percent drop (1-5%) using limit orders at predetermined prices</h2>
    <div id="period-controls" style="text-align:center; margin:12px 0;">
        <button id="ytd-btn" class="period-btn">YTD</button>
        <button id="5y-btn" class="period-btn">5 Years</button>
        <button id="10y-btn" class="period-btn">10 Years</button>
        <button id="15y-btn" class="period-btn">15 Years</button>
        <button id="20y-btn" class="period-btn">20 Years</button>
    </div>
    <div id="charts-root"></div>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
    <script>
    // Period control state
    let currentPeriod = 'YTD';

    // Small helper to format Date as YYYY-MM-DD
    function formatDateToYMD(d) {
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, '0');
        const dd = String(d.getDate()).padStart(2, '0');
        return `${yyyy}-${mm}-${dd}`;
    }

    // Return {startDate, endDate} as YYYY-MM-DD strings for a given period and reference end date
    function getPeriodRange(periodName, endDateStr) {
        const endDate = endDateStr ? new Date(endDateStr) : new Date();
        let startDate = new Date(endDate);
        if (periodName === 'YTD') {
            startDate = new Date(endDate.getFullYear(), 0, 1);
        } else if (periodName === '5Y') {
            startDate.setFullYear(endDate.getFullYear() - 5);
        } else if (periodName === '10Y') {
            startDate.setFullYear(endDate.getFullYear() - 10);
        } else if (periodName === '15Y') {
            startDate.setFullYear(endDate.getFullYear() - 15);
        } else if (periodName === '20Y') {
            startDate.setFullYear(endDate.getFullYear() - 20);
        }
        return { startDate: formatDateToYMD(startDate), endDate: formatDateToYMD(endDate) };
    }

    // Helper function to format currency with commas
    function formatCurrency(amount) {
        return '$' + amount.toLocaleString('en-US', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
    }
    
    function percentGain(value, invested) {
        if (invested === 0 || invested == null || value == null) return '';
        return ((value - invested) / invested * 100).toFixed(2) + '%';
    }

    // Calculate detailed metrics for a specific ticker
    function calculateDetailedMetrics(processedData, ticker, rawTickerData) {
        const tickerResults = processedData[ticker] || [];
        
        if (tickerResults.length === 0) {
            return {
                totalDips: 0,
                totalInvested: 0,
                totalValue: 0,
                gainLoss: 0
            };
        }

        const lastResult = tickerResults[tickerResults.length - 1];
        const totalDips = lastResult.cumulativeShares;
        const totalInvested = lastResult.cumulativeInvested;
        const totalValue = lastResult.cumulativeValue;
        const gainLoss = totalValue - totalInvested;

        return {
            totalDips,
            totalInvested,
            totalValue,
            gainLoss
        };
    }

    // Display detailed metrics in a grid format
    function displayDetailedMetrics(metrics) {
        const isPositive = metrics.gainLoss >= 0;
        const gainLossClass = isPositive ? 'positive' : 'negative';
        
        return `
            <div class="metrics-grid">
                    <!-- Total Weeks removed -->
                <div class="metric-card">
                    <div class="metric-label">Total Dips/Purchases</div>
                    <div class="metric-value">${metrics.totalDips}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Total Invested</div>
                    <div class="metric-value">${formatCurrency(metrics.totalInvested)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Total Value</div>
                    <div class="metric-value">${formatCurrency(metrics.totalValue)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Gain/Loss</div>
                    <div class="metric-value ${gainLossClass}">${percentGain(metrics.totalValue, metrics.totalInvested)}</div>
                </div>
            </div>
        `;
    }
    // Fetch and parse CSV data
    async function fetchData() {
        const response = await fetch('../data/history_tickers.csv');
        const text = await response.text();
        const rows = text.split('\n').filter(Boolean);
        const headers = rows[0].split(',');
        const data = rows.slice(1).map(row => {
            const values = row.split(',');
            const obj = {};
            headers.forEach((h, i) => obj[h.trim()] = values[i]);
            return obj;
        });
        return data;
    }

    // Calculate buy-on-dip strategy for a specific ticker
    function calculateBuyOnDip(tickerData) {
        // Sort by date
        const sortedData = tickerData.sort((a, b) => new Date(a.Date_add) - new Date(b.Date_add));
        
        let cumulativeShares = 0;
        let cumulativeInvested = 0;
        const results = [];

        for (let i = 1; i < sortedData.length; i++) {
            const today = sortedData[i];
            const yesterday = sortedData[i - 1];
            
            const todayLow = today.Low != null ? parseFloat(today.Low) : NaN;
            const todayClose = today.Close != null ? parseFloat(today.Close) : NaN;
            const yesterdayClose = yesterday.Close != null ? parseFloat(yesterday.Close) : NaN;

            let dayShares = 0;
            let dayInvested = 0;

            // Prefer explicit fields from the data when available (these may come from a precomputed BOD CSV)
            const explicitShares = (today['Shares Purchased'] != null) ? Number(today['Shares Purchased']) :
                                   (today['Shares_Purchased'] != null) ? Number(today['Shares_Purchased']) :
                                   (today.SharesPurchased != null) ? Number(today.SharesPurchased) : null;
            const explicitInvested = (today['Dollars Invested'] != null) ? Number(today['Dollars Invested']) :
                                     (today['Dollars_Invested'] != null) ? Number(today['Dollars_Invested']) :
                                     (today.DollarsInvested != null) ? Number(today.DollarsInvested) : null;
            const explicitBuyPrice = (today['Buy_Price'] != null) ? Number(today['Buy_Price']) :
                                     (today.Buy_Price != null) ? Number(today.Buy_Price) :
                                     (today.BuyPrice != null) ? Number(today.BuyPrice) : null;

            if (explicitShares != null || explicitInvested != null) {
                // Use explicit numbers if present
                dayShares = explicitShares != null ? explicitShares : 0;
                dayInvested = explicitInvested != null ? explicitInvested : (explicitBuyPrice != null ? explicitBuyPrice * dayShares : 0);
            } else if (explicitBuyPrice != null) {
                // If only a buy price is provided, assume 1 share purchased unless Shares provided
                dayShares = 1;
                dayInvested = explicitBuyPrice;
            } else {
                // Fallback: compute by checking the low against previous close (limit orders at 1-5%)
                if (!isNaN(todayLow) && !isNaN(yesterdayClose)) {
                    for (let dipLevel = 1; dipLevel <= 5; dipLevel++) {
                        const limitOrderPrice = yesterdayClose * (1 - dipLevel / 100);
                        if (todayLow <= limitOrderPrice) {
                            dayShares += 1;
                            dayInvested += limitOrderPrice;
                        }
                    }
                }
            }

            if (dayShares > 0) {
                cumulativeShares += dayShares;
                cumulativeInvested += dayInvested;

                results.push({
                    date: today.Date_add,
                    close: todayClose,
                    sharesThisDay: dayShares,
                    investedThisDay: dayInvested,
                    cumulativeShares: cumulativeShares,
                    cumulativeInvested: cumulativeInvested,
                    cumulativeValue: (!isNaN(todayClose) ? cumulativeShares * todayClose : null)
                });
            }
        }

        return results;
    }
    function getAllDates(processedData) {
        const allDates = new Set();
        Object.values(processedData).forEach(tickerResults => {
            tickerResults.forEach(result => allDates.add(result.date));
        });
        return Array.from(allDates).sort();
    }

    function prepareSeries(processedData, ticker, allDates) {
        const tickerResults = processedData[ticker] || [];
        const valueMap = Object.fromEntries(tickerResults.map(result => [result.date, result.cumulativeValue]));
        const investedMap = Object.fromEntries(tickerResults.map(result => [result.date, result.cumulativeInvested]));
        
        return [
            {
                name: ticker + ' - Value',
                type: 'line',
                connectNulls: true,
                data: allDates.map(date => valueMap[date] ?? null),
                showSymbol: false
            },
            {
                name: 'Invested',
                type: 'line',
                connectNulls: true,
                data: allDates.map(date => investedMap[date] ?? null),
                showSymbol: false,
                lineStyle: { type: 'dashed' }
            }
        ];
    }
    async function renderAllCharts(period = 'YTD') {
        const rawData = await fetchData();
        
        // Group data by ticker
        const tickerGroups = {};
        rawData.forEach(row => {
            const ticker = row.Symbol;
            if (!tickerGroups[ticker]) {
                tickerGroups[ticker] = [];
            }
            tickerGroups[ticker].push(row);
        });

        // Apply timeframe filter using period and reference end date
        const historyDates = rawData.map(r => r.Date_add).filter(Boolean).sort();
        const referenceEnd = historyDates.length ? historyDates[historyDates.length - 1] : new Date().toISOString().slice(0,10);
        const range = getPeriodRange(period, referenceEnd);

        // Calculate buy-on-dip results for each ticker using filtered rows
        const processedData = {};
        Object.keys(tickerGroups).forEach(ticker => {
            const rows = tickerGroups[ticker].filter(r => {
                if (!range.startDate || !range.endDate) return true;
                return r.Date_add >= range.startDate && r.Date_add <= range.endDate;
            });
            processedData[ticker] = calculateBuyOnDip(rows);
        });

        // Get tickers and sort by percent return (descending)
        let tickers = Object.keys(processedData).filter(ticker => processedData[ticker].length > 0);
        
        tickers = tickers.map(ticker => {
            const results = processedData[ticker];
            let pct = -Infinity;
            if (results.length > 0) {
                const last = results[results.length - 1];
                pct = last.cumulativeInvested ? ((last.cumulativeValue - last.cumulativeInvested) / last.cumulativeInvested * 100) : -Infinity;
            }
            return { ticker, pct };
        }).sort((a, b) => b.pct - a.pct).map(obj => obj.ticker);

    const allDates = getAllDates(processedData);
        const root = document.getElementById('charts-root');
        root.innerHTML = '';

        for (const ticker of tickers) {
            // Create container
            const container = document.createElement('div');
            container.className = 'chart-container';
            
            // Calculate detailed metrics for this ticker
            const metrics = calculateDetailedMetrics(processedData, ticker, tickerGroups[ticker]);
            
            // Calculate overall percent return for this ticker
            const tickerResults = processedData[ticker];
            let summary = '';
            if (tickerResults.length > 0) {
                const last = tickerResults[tickerResults.length - 1];
                const pct = percentGain(last.cumulativeValue, last.cumulativeInvested);
                summary = `<span style="color:#007700;font-size:1rem;">${ticker} Overall % Gain: <b>${pct}</b></span>`;
            }
            
            // Title
            const title = document.createElement('div');
            title.className = 'chart-title';
            title.innerHTML = `${ticker} Buy on Dip &nbsp; ${summary}`;
            container.appendChild(title);
            
            // Add detailed metrics
            const metricsDiv = document.createElement('div');
            metricsDiv.innerHTML = displayDetailedMetrics(metrics);
            container.appendChild(metricsDiv);
            
            // Chart div
            const chartDiv = document.createElement('div');
            chartDiv.style.width = '100%';
            chartDiv.style.height = '400px';
            container.appendChild(chartDiv);
            root.appendChild(container);

            // Prepare series
            const series = prepareSeries(processedData, ticker, allDates);
            
            // Build lookup for percent gain
            const gainLookup = {};
            tickerResults.forEach(result => {
                gainLookup[result.date] = {
                    value: result.cumulativeValue,
                    invested: result.cumulativeInvested
                };
            });

            // Render chart
            const chart = echarts.init(chartDiv);
            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'cross' },
                    formatter: function(params) {
                        let html = params[0].axisValue + '<br/>';
                        params.forEach(p => {
                            // Avoid printing Value/Invested/Shares here to prevent duplication; we'll show them in the consolidated summary below
                            if (p.seriesName.includes('Value') || p.seriesName.includes('Invested') || p.seriesName.includes('Shares')) return;
                            let val = (typeof p.value === 'number' && !isNaN(p.value)) ? p.value : (Array.isArray(p.value) && p.value.length > 1 && !isNaN(p.value[1]) ? p.value[1] : '');
                            html += '<span style="color:' + p.color + '">●</span> ' + p.seriesName + ': ' + val + '<br/>';
                        });
                        const key = params[0].axisValue;
                        if (gainLookup[key]) {
                            const info = gainLookup[key];
                            const investedStr = (info.invested != null) ? formatCurrency(info.invested) : '';
                            const valueStr = (info.value != null) ? formatCurrency(info.value) : '';
                            const sharesStr = (info.shares != null) ? info.shares : '';
                            html += '<b>Invested: ' + investedStr + ' &nbsp; Value: ' + valueStr + '</b><br/>';
                            if (sharesStr !== '') html += '<b>Shares: ' + sharesStr + '</b><br/>';
                            html += '<b>% Gain: ' + percentGain(info.value, info.invested) + '</b><br/>';
                        }
                        return html;
                    }
                },
                legend: { data: series.map(s => s.name) },
                xAxis: { type: 'category', data: allDates, name: 'Date' },
                yAxis: { type: 'value', name: 'USD' },
                series: series
            };
            chart.setOption(option);
        }
    }

    // Wire up period buttons
    function setActivePeriodButton(id) {
        document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(id).classList.add('active');
    }

    document.getElementById('ytd-btn').addEventListener('click', async () => { currentPeriod = 'YTD'; setActivePeriodButton('ytd-btn'); await renderAllCharts('YTD'); });
    document.getElementById('5y-btn').addEventListener('click', async () => { currentPeriod = '5Y'; setActivePeriodButton('5y-btn'); await renderAllCharts('5Y'); });
    document.getElementById('10y-btn').addEventListener('click', async () => { currentPeriod = '10Y'; setActivePeriodButton('10y-btn'); await renderAllCharts('10Y'); });
    document.getElementById('15y-btn').addEventListener('click', async () => { currentPeriod = '15Y'; setActivePeriodButton('15y-btn'); await renderAllCharts('15Y'); });
    document.getElementById('20y-btn').addEventListener('click', async () => { currentPeriod = '20Y'; setActivePeriodButton('20y-btn'); await renderAllCharts('20Y'); });

    // Initial render (YTD)
    setActivePeriodButton('ytd-btn');
    renderAllCharts('YTD');
    </script>
</body>
</html>